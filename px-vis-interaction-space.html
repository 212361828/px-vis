<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-vis-behavior-common.html" />
<link rel="import" href="px-vis-behavior-d3.html" />
<link rel="import" href="../px-colors-design/colors.html" />


<!--
Element providing on-chart hover functionality to get data values near the mouse cursor and listen to mouse events on the chart.
- Sets tooltipData property which can then be used to share adjacent datapoint values with other components, such as the register.


##### Usage

    <px-vis-interaction-space
        svg="[[svg]]"
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]"
        chart-data="[[chartData]]"
        x="[[x]]"
        y="[[y]]"
        current-domain-x="[[currentDomainX]]"
        current-domain-y="[[currentDomainY]]">
    </px-vis-interaction-space>

@element px-vis-interaction-space
@blurb Element providing on-chart hover functionality to get data values near the mouse cursor.
@homepage index.html
@demo demo.html

TODO implement a dev setting to choose between only showing data at that x, snapping to nearest data, or interpolating value at x

-->
<dom-module id="px-vis-interaction-space">
    <link rel="import" type="css" href="css/px-vis.css"/>
    <template>

    </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-interaction-space',

    behaviors: [
      PxVisBehavior.sizing,
      PxVisBehavior.svg,
      PxVisBehavior.axes,
      PxVisBehavior.dataset,
      PxVisBehavior.tooltipData,
      PxVisBehavior.interaction,
      commonColors
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * Holder for the interaction rectangle object
       *
       * @property _rect
       * @type Object
       */
      _rect:{
        type:Object,
        value:{}
      }
    }, //properties

    observers: [
      'drawElement(currentDomainX,currentDomainY,chartData.*)'
     ],

    /**
     * Draws the tooltip elements and sets up listeners and callbacks on chart hover
     * Sets the tooltipData property which gets passed to the register.
     *
     * @method drawElement
     */
    drawElement: function() {
      if(typeof(this.svg) !== 'undefined' && !this._isObjEmpty(this.x) && !this._isObjEmpty(this.y) && (this.chartData) && this._isObjEmpty(this._rect)){

        // make sure the tooltip draws on top of everything; returns a set property interactionSvg
        this.cloneSVGElem(this.svg[0][0],'interactionSvg');
        this.fire('px-vis-interaction-svg-updated', { 'dataVar': 'interactionSvg', 'data': this.interactionSvg, 'method':'set' });

        // append the rectangle to capture mouse interactions
        this._rect = this.interactionSvg.append("rect")
          .attr('id',"mouseCapture")
          .attr("width", this.width)
          .attr("height", this.height)
          .attr("fill", "none")
          .attr("pointer-events", "all")
          .on("mouseover", (this._mouseOver).bind(this))
          .on("mouseout", (this._resetTooltipData).bind(this))
          .on("mousemove",(this._calcDataPoints).bind(this))
          .on("click",function(){ console.log(d3.event)})
          .style("cursor","crosshair");

        // send the register etc an empty list of series
        this._resetTooltipData();
      }  //if we have vars
    },  //drawElement
    /**
     * Helper function called on mouseover
     * Shows the tooltip elements
     *
     * @method _clearTooltip
     */
    _mouseOver:function() {
      // trigger mouseover
    },

    /**
     * Helper function called on mouseout
     * Hides the tooltip elements and resets tooltipData
     *
     * @method _resetTooltipData
     */
    _resetTooltipData: function() {
      var ttD = {
        'time': null,
        'series': [],
        'mouse': null,
        'xArr': null,
        'yArr': null
      };

      for(var i = 0; i < this.chartData.length; i++){
        ttD.series.push({'name':this.chartData[i]['name'],'value': [null,null] });
      }

      this.set('tooltipData',ttD);
      this.fire('px-vis-tooltip-updated', { 'dataVar': 'tooltipData', 'data': ttD, 'method':'set' });
      console.log("mouseout");
      // trigger a mouseout
    },

    /**
     * Helper function called on mousemove
     * Calculates the mouse position and associated x & y values. Then sets the d3 elements and sets tooltipData for consumption elsewhere
     *
     * @method _calcDataPoints
     */
    _calcDataPoints:function(){
      //  d3.mouse: returns the x position on the screen of the mouse
      var mousePos = d3.mouse(this._rect[0][0]);

      this.debounce('move',function(){
        // invert: takes position on the screen and converts it into an equivalent date
        var x0 = this.x.invert(mousePos[0]);

        // setup a holder for our data to pass out
        var dataObj = {
          'time': x0,
          'series': [],
          'mouse': mousePos,
          'xArr': null,
          'yArr': null
        };

        /*
          d3.bisector returns index in our array that corresponds to the horizontal position of the mouse pointer.
          Specifically this returns the date that falls to the left of the mouse cursor.
        */
        var bisectDate = d3.bisector(function(d) { return d[0]; }).left;

        var xArr = [],
            yArr = [];
        for(var i = 0; i < this.chartData.length; i++){
          // define vars
          var index, d0, d1, d, xCoord, yCoord;
          // get the index number of the timestamp
          index = bisectDate(this.chartData[i]['series'], x0, 1);
          // get the data values around the index
          d0 = this.chartData[i]['series'][index - 1];
          d1 = (this.chartData[i]['series'][index]) ? this.chartData[i]['series'][index] : this.chartData[i]['series'][index - 1];
          // sets d as the closest date to the mouse
          d = x0 - d0[0] > d1[0] - x0 ? d1 : d0;

          // get the pixel coords for that data
          xCoord = this.x(d[0]);
          yCoord = this.y(d[1]);

          xArr.push(xCoord);
          yArr.push(yCoord);

          dataObj.series.push({'name':this.chartData[i]['name'],'value': d, 'coord': [xCoord,yCoord] });
        } //for

        dataObj['xArr'] = xArr;
        dataObj['yArr'] = yArr;

        // now we can set our data that we want to pass out
        this.set('tooltipData',dataObj);
        this.fire('px-vis-tooltip-updated', { 'dataVar': 'tooltipData', 'data': dataObj, 'method':'set' });
      },1)
    } //mousemove
  });
</script>
