<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-vis-behavior-common.html" />
<link rel="import" href="px-vis-behavior-d3.html" />
<link rel="import" href="../px-colors-design/colors.html" />


<!--
Element providing on-chart hover functionality to get data values near the mouse cursor and listen to mouse events on the chart.
- Sets tooltipData property which can then be used to share adjacent datapoint values with other components, such as the register.


##### Usage

    <px-vis-interaction-space
        svg="[[svg]]"
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]"
        chart-data="[[chartData]]"
        x="[[x]]"
        y="[[y]]"
        current-domain-x="[[currentDomainX]]"
        current-domain-y="[[currentDomainY]]"
        tooltip-data="{{tooltipData}}"
        extents-data="{{extentsData}}">
    </px-vis-interaction-space>

@element px-vis-interaction-space
@blurb Element providing on-chart hover functionality to get data values near the mouse cursor.
@homepage index.html
@demo demo.html

TODO implement a dev setting to choose between only showing data at that x, snapping to nearest data, or interpolating value at x

-->
<dom-module id="px-vis-interaction-space">
    <link rel="import" type="css" href="css/px-vis.css"/>
    <template>

    </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-interaction-space',

    behaviors: [
      PxVisBehavior.sizing,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.axes,
      PxVisBehavior.dataset,
      PxVisBehavior.tooltipData,
      PxVisBehavior.extentsData,
      PxVisBehavior.commonMethods,
      PxVisBehavior.axisTypes,
      PxVisBehaviorD3.interaction,
      commonColors
    ],
    /***EVENTS****
    /*
    * fires an update to the interaction svg
    * @event px-vis-interaction-svg-updated
    */
    /*
    * fires an update to the tooltip
    * @event px-vis-tooltip-updated
    */

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * Holder for the interaction rectangle object
       *
       * @property _rect
       * @type Object
       */
      _rect:{
        type:Object,
        value: function() {return{};}
      },
      /**
       * an object that contains meta data for the area drawn by the user
       *
       * @property _actionArea
       * @type Object
       */
      _actionArea: {
        type: Object,
        value: function() {return {};}
      },
      /**
       *
       * The shape of selection the user can do. Can be:
       * - 'rectangle': user can draw a rectangle freely
       * - 'xAxis': user can select a range withing the X axis, the Y axis always
       *   being entirely selected
       * - 'YAxis': user can select a range withing the Y axis, the X axis always
       *   being entirely selected
       */
      selectionType: {
        type: String,
        value: 'rectangle'
      },
      _sortedXData: {
        type: Array,
        computed: '_getSortedXData(chartData, xAxisType)'
      },
      _sortedYData: {
        type: Array,
        computed: '_getSortedYData(chartData, yAxisType)'
      },
      _voronois: {
        type: Array,
        value: function() {
          return [];
        }
      }
    },

    observers: [
      'drawElement(currentDomainX,currentDomainY,chartData.*,svg,width,height)'
     ],

    /**
    * when attached, re-fire set properties for precipitation pattern
    *
    * @method attached
    */
    attached: function(){
      if(this._isObjHaveValues(this.interactionSvg)){
        this.fire('px-vis-interaction-svg-updated', { 'dataVar': 'interactionSvg', 'data': this.interactionSvg, 'method':'set' });
      }

      if(this._isObjHaveValues(this.tooltipData)){
        this.fire('px-vis-tooltip-updated', { 'dataVar': 'tooltipData', 'data': this.tooltipData, 'method':'set' });
      }

    },

    /**
     * Draws the tooltip elements and sets up listeners and callbacks on chart hover
     * Sets the tooltipData property which gets passed to the register.
     *
     * @method drawElement
     */
    drawElement: function() {
      if (this._isObjHaveValues(this.svg) && this._isObjHaveValues(this.x) && this._isObjHaveValues(this.y) && this._isObjHaveValues(this.chartData) && this._isObjEmpty(this._rect) && this.width && this.height ) {
        // make sure the tooltip draws on top of everything; returns a set property interactionSvg
        this.cloneSVGElem(this.svg.node(),'interactionSvg');
        this.fire('px-vis-interaction-svg-updated', { 'dataVar': 'interactionSvg', 'data': this.interactionSvg, 'method':'set' });



        if(this.xAxisType !== 'time' && this.xAxisType !== 'ordinal' && this.yAxisType !== 'ordinal') {

          //reset voronois
          this._voronois = [];

          //and calculate them
          for(var i=0; i < this.chartData.length; i++) {
          //create a voronoi grid to detect which point the tooltip should relate to
          var _this = this;
          var voronoi = d3.geom.voronoi()
          	.x(function(d) { return _this.x(d[0]); })
          	.y(function(d) { return _this.y(d[1]); })
          	.clipExtent([[0, 0],
              [this.width - this.margin.left - this.margin.right,
                this.height - this.margin.bottom - this.margin.top]]);

          //Initiate a group element to place the voronoi diagram in
          var voronoiGroup = this.interactionSvg.append("g")
          	.attr("class", "voronoiWrapper" + i);

          //Create the Voronoi diagram
          voronoiGroup.selectAll("path")
          	.data(voronoi(this.chartData[i].series)) //Use vononoi() with your dataset inside
          	.enter().append("path")
          	.attr("d", function(d, i) { return "M" + d.join("L") + "Z"; })
          	.datum(function(d, i) { return d; })
          	//Give each cell a unique class where the unique part corresponds to the circle classes
          	.attr("class", function(d,i) { return "voronoi " + d[0]; })
          	.style("stroke", "#" + i + i + i + "4A0")
          	.style("stroke-opacity", 0.5)
          	.style("fill", "none")
          	.style("pointer-events", "all")
          	.on("mouseover", _this.showTooooltip);
          //	.on("mouseout",  removeTooltip);

          this._voronois.push(voronoiGroup);
          }


        } else {
        // append the rectangle to capture mouse interactions
        this._rect = this.interactionSvg.append("rect")
          .attr('id',"mouseCapture")
          .attr("width", this.width - this.margin.left - this.margin.right)
          .attr("height", this.height - this.margin.bottom - this.margin.top)
          .attr("fill", "none")
          .attr("pointer-events", "all")
          .on("mouseover", this._mouseOver.bind(this))
          .on("mouseout.tooltip", this._resetTooltipData.bind(this))
          .on("mousemove.tooltip",this._calcTooltipData.bind(this))
          .on("mousedown.action", this._drawActionBox.bind(this))
          .on("mousemove.action", this._updateActionBox.bind(this))
          .on("mouseup.action", this._finishActionBox.bind(this))
          .style("cursor","crosshair");
        }


          // TODO touchevents
          // TODO if there is no register tooltip or cursor, set .tooltip listeners to null
          // TODO if there is no zoom or action panel, set action listeners to null

        // send the register etc an empty list of series
        this._resetTooltipData();
      }  //if we have vars
    },  //drawElement
    /**
     * Helper function called on mouseover
     * Shows the tooltip elements
     *
     * @method _clearTooltip
     */
    _mouseOver:function() {
      // trigger mouseover
    },
showTooooltip: function(test) {


  console.log('point: ' + test.point[0] + ', ' + test.point[1]);
},
    /**
     * Helper function called on mouseout
     * Hides the tooltip elements and resets tooltipData
     *
     * @method _resetTooltipData
     */
    _resetTooltipData: function() {
      var ttD = {
            'time': null,
            'series': [],
            'mouse': null,
            'xArr': null,
            'yArr': null
          },
          len = this.chartData.length,
          i;


      for(i = 0; i < len; i++){
        ttD.series.push({'name':this.chartData[i]['name'],'value': null });
      }

      this.set('tooltipData',ttD);
      this.fire('px-vis-tooltip-updated', { 'dataVar': 'tooltipData', 'data': ttD, 'method':'set' });
    },

    /**
     * Helper function called on mousemove
     * Calculates the mouse position and associated x & y values. Then sets the d3 elements and sets tooltipData for consumption elsewhere
     *
     * @method _calcTooltipData
     */
    _calcTooltipData:function(evt){
      //  d3.mouse: returns the x position on the screen of the mouse
      var mousePos = d3.mouse(this._rect.node()),
          x0,
          dataObj,
          bisectDate,
          xArr,
          yArr,
          len,
          index,
          d0,
          d1,
          d,
          xCoord,
          yCoord;

          var evt = document.createEvent ("MouseEvent"),
              d3Evt = d3.event;
        evt.initMouseEvent (
            "mouseover", true, true, window, 0,
            d3Evt.screenX, d3Evt.screenY, d3Evt.clientX, d3Evt.clientY,
            d3Evt.ctrlKey, d3Evt.altKey, d3Evt.shiftKey, d3Evt.metaKey,
            0, null);

          this._voronois.forEach(function(vor, index) {
            vor.selectAll("path")[0].forEach(function(el, i) {
              el.dispatchEvent(evt);});
          });
      this.debounce('move',function(){

        // invert: takes position on the screen and converts it into an equivalent date
        var minDist = Number.MAX_VALUE,
            result = [],
            xArr = [],
            yArr = [],
            len  = this.chartData.length,
            d,
            x1,
            y1,
            x2,
            y2;

            if(this.xAxisType !== 'ordinal') {
              //convert mouse position to position on the chart
              x1 = this.x.invert(mousePos[0]);
            } else {
              //if we're ordinal we can find out the x value directly
              x2 = this._findOrdinalValue(true, mousePos[0]);
            }

            if(this.yAxisType !== 'ordinal') {
              //convert mouse position to position on the chart
              y1 = this.y.invert(mousePos[1]);
            } else {
              //if we're ordinal we can find out the y value directly
              y2 = this._findOrdinalValue(false, mousePos[1]);
              y1 = y2;
            }

            // setup a holder for our data to pass out
            var dataObj = {
              'time': this.xAxisType === 'time' ? x1 : null,
              'series': [],
              'mouse': mousePos,
              'xArr': null,
              'yArr': null
            };

            for(var i = 0; i < len; i++) {

              minDist = Number.MAX_VALUE;
              result = [];

              //searching for our closest point depending on axis types
              if(this.xAxisType === 'linear') {


                //non time based: iterate over points and find the closest
                for(var j = 0; j < this.chartData[i].series.length; j++) {

                  //get point coords
                  x2 = this.chartData[i].series[j][0];
                  y2 = this.chartData[i].series[j][1];

                  //distance between the two points
                  d = Math.sqrt( (x2-=x1)*x2 + (y2-=y1)*y2 );

                  //keep the closest point
                  if(d < minDist) {
                    minDist = d;
                    result = this.chartData[i].series[j];
                  }
                }
              } else if(this.xAxisType === 'time') {
                //time based X axis
                /*
                  d3.bisector returns index in our array that corresponds to the horizontal position of the mouse pointer.
                  Specifically this returns the date that falls to the left of the mouse cursor.
                */
                var bisectDate = d3.bisector(function(d) { return d[0]; }).left,
                    index = bisectDate(this.chartData[i].series, x1, 1);
                // get the data values around the index
                d0 = this.chartData[i].series[index - 1];
                d1 = (this.chartData[i].series[index]) ? this.chartData[i].series[index] : this.chartData[i].series[index - 1];
                // sets result as the closest date to the mouse
                result = (x1 - d0[0] > d1[0] - x1) ? d1 : d0;
              }

              // get the pixel coords for that data
              xCoord = this.x(result[0]);
              yCoord = this.y(result[1]);

              xArr.push(xCoord);
              yArr.push(yCoord);

              dataObj.series.push({'name':this.chartData[i]['name'],'value': result, 'coord': [xCoord,yCoord] });
            } //for


          dataObj['xArr'] = xArr;
          dataObj['yArr'] = yArr;

          // now we can set our data that we want to pass out
          this.set('tooltipData',dataObj);
          this.fire('px-vis-tooltip-updated', { 'dataVar': 'tooltipData', 'data': dataObj, 'method':'set' });
      },1);
    },

    _findOrdinalValue: function(isX, mousePos) {

      var xOrY = isX ? this.x : this.y;
      return xOrY.domain()[d3.bisect(xOrY.rangeExtent(), mousePos) - 1];
    },


    _getSortedXData: function() {

      var result = [],
          len = this.chartData.length;

      //don't sort ordinal data
      if(this.xAxisType !== 'ordinal') {
        //sort based on X, from smaller to bigger
        for(var i = 0; i < len; i++) {

          //sort based on X, from smaller to bigger
          result[i] = this.chartData[i].series.sort(function(a, b) {
            return a[0]-b[0];
          });
        }
      }
      return result;
    },
    _getSortedYData: function() {
      var result = [],
          len = this.chartData.length;

      //don't sort ordinal data
      if(this.xAxisType !== 'ordinal') {
        //sort based on X, from smaller to bigger
        for(var i = 0; i < len; i++) {

          //sort based on Y, from smaller to bigger
          result[i] = this.chartData[i].series.sort(function(a, b) {
            return a[1]-b[1];
          });
        }
      }
      return result;
    },
    /**
     * Helper function called on document.mouseup
     * assumes the user wanted to "close" the action box, and calls _finishActionBox
     *
     * @method _mouseUpOutsideSvg
     */
    _mouseUpOutsideSvg: function() {
      this._finishActionBox();
    },
    /**
     * Helper function called on mousedown.action
     * Draws a rectangle on the chart
     *
     * @method _drawActionBox
     */
    _drawActionBox: function(){
      this.mouseDown = true;
      //in case the user clicks inside the chart, and mouses out, we are waiting for a mouseup, and closing our action box with the coordinates available on the mouseup.
      d3.select(document).on('mouseup.action', this._mouseUpOutsideSvg.bind(this));

      var mousePos = d3.mouse(this._rect.node());
      // use original svg so it draws under the _rect and does not interfer with our mouse events

      var startX = mousePos[0],
          startY = mousePos[1];

      if(this.selectionType === 'xAxis') {
        startY = 0;
      } else if(this.selectionType === 'yAxis') {
        startX = 0;
      }

      this._actionArea = this.svg.append( "rect")
        .attr('class', "action-area")
        .attr('x', startX)
        .attr('y', startY)
        .attr('ox', startX) // save this original position for calcs
        .attr('oy', startY) // save this original position for calcs
        .attr('rx', 2)
        .attr('ry', 2)
        .attr('width', 0)
        .attr('height', 0)
        .attr('fill', this.colors.grey2)
        .attr('fill-opacity', 0.5)
        .attr('stroke', this.colors.grey6);
    },
    /**
     * Helper function called on mousedown.action
     * Updates the size of the action area rectangle
     *
     * @method _updateActionBox
     */
    _updateActionBox: function() {

      if(this._isObjHaveValues(this._actionArea)) {

        var mousePos = d3.mouse(this._rect.node()),
          // save somewhere else--> not as an attr, inefficient
            ox = parseInt(this._actionArea.attr("ox")),
            oy = parseInt(this._actionArea.attr("oy")),
            newX = mousePos[0],
            newY = mousePos[1];

        if(this.selectionType === 'xAxis') {
          newY = this._rect.attr('height');
        } else if(this.selectionType === 'yAxis') {
          newX = this._rect.attr('width');
        }

        // if current position is greater than the original position
        if(newX >= ox){
          // set x to the original position to prevent some drift on crossover. width is equal to the difference between the x and current mouse position
          this._actionArea.attr("x", ox);
          this._actionArea.attr("width", newX - ox);
        } else {
          // else, the x is the current pos (because we cant have negative width) and width is the difference
          this._actionArea.attr("x", newX);
          this._actionArea.attr("width", ox - newX);
        }

        if(newY >= oy){
          this._actionArea.attr("y", oy);
          this._actionArea.attr("height", newY - oy);
        } else {
          this._actionArea.attr("y", newY);
          this._actionArea.attr("height", oy - newY);
        }
      }
    },

    /**
     * Helper function called on mouseup.action
     * Gets the size of the action area rectangle, sets the extents, and removes it
     *
     * @method _finishActionBox
     */
    _finishActionBox: function() {
      //since we are done drawing our action box, remove the listener from document using d3.
      d3.select(document).on('mouseup.action', null);
      this.mouseDown = false;
      var extents = {};

      //make sure we have somthing selected
      if(this._actionArea.attr("width") > 0 && this._actionArea.attr("height") > 0) {
        extents.x1 = parseInt(this._actionArea.attr("x"));
        extents.y1 = parseInt(this._actionArea.attr("y"));
        extents.w = parseInt(this._actionArea.attr("width"));
        extents.h = parseInt(this._actionArea.attr("height"));
        extents.x2 = extents.x1 + extents.w;
        extents.y2 = extents.y1 + extents.h;
        extents.eX = [this.x.invert(extents.x1), this.x.invert(extents.x2)];
        //Y axis is top to bottom
        extents.eY = [this.y.invert(extents.y2), this.y.invert(extents.y1)];

        this.set('extentsData', extents);
        this.fire('px-vis-extents-data-updated', {'data': extents, 'dataVar': 'extentsData', 'method': 'set'});
      }
      this._actionArea.remove();
    }
  });
</script>
