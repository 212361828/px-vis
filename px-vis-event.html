<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-vis-common.html" />
<link rel="import" href="px-vis-svg-chart-common.html" />
<link rel="import" href="../px-colors-design/colors.html" />


<!--
Element providing solution to no problem in particular. As a simple, increments a counter when clicked.

##### Usage

    <px-vis counter-value="1">Hi</px-vis>

@element px-vis
@blurb Element providing solution to no problem in particular.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-vis-event">
    <link rel="import" type="css" href="css/px-vis.css"/>
    <template>

    </template>
</dom-module>

<script>
    Polymer({

        is: 'px-vis-event',

        behaviors: [
          pxVisSVGChartCommonBehavior,
          commonColors
        ],

        /**
         * Properties block, expose attribute values to the DOM via 'reflect'
         *
         * @property properties
         * @type Object
         */
        properties: {
          eventId:{
            type:String,
            value: '',
            notify: true,
            reflectToAttribute: true
          },
          /**
           * Configuration object to define what event should map to what icon and color
           *
           *
           *
           *
           * @property eventConfig
           * @type Object
           */
          eventConfig:{
            type:Object,
            value:{
              'eventName':{
                'color':'yellow',
                'icon':''
              }

            }
          },
          eventGroup:{
            type:Object,
            value:{}
          },
        },

        observers: [
          // TODO Does chartData need to be chartData.* or chartData.series.* for dynamic data?
          'drawElement(svg,x,y,setDomainX,setDomainY,chartData)',
         ],

        ready:function(){
          // if there is no dev set unique ID, generate one
          if(!this.eventId){
            this.set('eventId', this.generateRandomID('event_'));
          }
        },

        /**
         * Draws or updates the line element.
         * Called from an observer watching for data and the necessary d3 objects
         *
         * @method drawElement
         */
        drawElement: function() {
          if(typeof(this.svg) !== 'undefined' && !this._isObjEmpty(this.x) && !this._isObjEmpty(this.y) && (this.chartData)){

            // checks to see if the axis already exists. If not, create; if so, update
            if(this._isObjEmpty(this.eventGroup)){

              this.svg.append('g')
                .attr('class','event')
                .attr('event-id',this.eventId);

              //keep a reference for later
              this.eventGroup = this.svg.select('g.event[event-id=' + this.eventId + ']');

              // draw the path
              this.eventGroup.append("line")
                .attr("x1", chartData[0])
                .attr("x2", chartData[1])
                .attr("y1", setDomainY[0])
                .attr("y2", setDomainY[1])
                .attr('stroke',this.colors.grey9);

              // TODO event type and icon
              var thisEvent = this.eventConfig[this.event]
              if(){
                nodeEnter.append("image")
      .attr("xlink:href", function(d) { return d.icon; })
      .attr("x", "-12px")
      .attr("y", "-12px")
      .attr("width", "24px")
      .attr("height", "24px");
              }

              // add color
              this._colorLine();

            } else {
              // update the path
              this.eventGroup.datum(data)
              // .duration(750)
              .attr("d", line);
            }
          }
        },
        /**
         * Checks mutedSeries to see if this ID is in there
         * Called from an observer watching mutedSeries
         *
         * @method isIdInMuted
         */
        isIdInMuted: function() {
          if(this.mutedSeries.hasOwnProperty(this.lineId)){
            // if true, mute
            if(this.mutedSeries[this.lineId]){
              this._muteLine()
            } else {
              this._colorLine()
            }
          }
          console.groupEnd();

        },
        /**
         * Adds full color to the line.
         *
         * @method _colorLine
         */
        _colorLine:function(){
          var index = this.seriesNumber;
          this.linePath.attr('stroke',this.dataVisColors[this.seriesColorOrder[index]])
            .attr('stroke-opacity',1);
        },
        /**
         * Adds muted color to the line.
         *
         * @method muteElements
         TODO add dev set color and opacity
         */
         _muteLine:function(){
           var index = this.seriesNumber;
           this.linePath.attr('stroke',this.dataVisColors[this.seriesColorOrder[index]])
             .attr('stroke-opacity',0.3);
         },
    });
</script>
