
<link rel="import" href="../px-colors-design/colors.html" />
<link rel="import" href="px-vis-behavior-common.html" />
<script>
var PxVisBehaviorChart = PxVisBehaviorChart || {};

/*
    Name:
    PxVisBehaviorChart.chartCommon

    Description:
    Polymer behavior that provides the basic listeners and methods for charts built with px-vis.

    Dependencies:
    - D3.js

    @polymerBehavior PxVisBehaviorChart.chartCommon
*/
PxVisBehaviorChart.chartCommon = [{
    properties: {
      /**
      * A configuration file to associate series order, name, type, and colors.
      *
      * Association of name, type, and seriesNumber should be developer set. Color and axis are optional.
      *
      *```
      *  {
      *     "seriesKey": {  //seriesKey is either an index or an object key used to identify the series
      *         "type": "line",  //line or scatter
      *         "name": "My Series",  //human readable name
      *         "x": 0,  //index or key name for independent variable
      *         "xMin": 0,  // minimum x value
      *         "xMax": 100,  //maximum x value
      *         "yMin": 5,  //minimum y value
      *         "yMax": 50,  //maximum y value
      *         "color": "rgb(0,0,0)", //color you want the chart
      *         "axis": "axis1"  //axis the chart should be on
      *     }
      *  }
      *```
      */
      seriesConfig: {
        type: Object,
        notify: true,
        value: function(){
          return {}
        }
      },
      /**
      * A default configuration file. It fills in the missing parts of seriesConfig.
      *
      */
      defaultSeriesConfig: {
        type: Object,
        notify: true,
        value: function(){
          // defaultSeriesConfig[xMin] cant be Infinity by default because then we cant assign it Infinity in json.
          return {
            "type": "line",
            "x": 'x',
            "xMin": "dynamic",
            "xMax": "dynamic",
            "yMin": 0,
            "yMax": "dynamic"
          }
        }
      },
      /**
      * A boolean flag on whether to include all the series in the data.
      * - `false`: only series defined in the seriesConfig file will be drawn
      * - `true`: All series in the dataset will be drawn. Defaults will be used for the seriesConfig
      */
      includeAllSeries: {
        type: Boolean,
        notify: true,
        value: false
      }
    },

    listeners:{
      'px-vis-svg-updated'              : '_updateLocalProperty',
      'px-vis-data-updated'             : '_updateLocalProperty',
      'px-vis-x-updated'                : '_updateLocalProperty',
      'px-vis-y-updated'                : '_updateLocalProperty',
      'px-vis-current-domain-x-updated' : '_updateLocalProperty',
      'px-vis-current-domain-y-updated' : '_updateLocalProperty',
      'px-vis-tooltip-updated'          : '_updateLocalProperty',
      'px-vis-interaction-svg-updated'  : '_updateLocalProperty',
      'px-vis-extents-data-updated'     : '_updateLocalProperty',
      'px-vis-clip-path-updated'        : '_updateLocalProperty',
      'px-vis-svg-element-updated'      : '_updateLocalProperty',

      'px-vis-muted-series-updated'     : '_updateGlobalProperty',
      'px-vis-selected-domain-updated'  : '_updateGlobalProperty'

    },

    observers: [
      '_setCompleteSeriesConfig(defaultSeriesConfig.*,chartData.*,seriesConfig.*)'
    ],

    _calcChartExts: function(mins,maxes,axis){
      if(this[axis + 'Scale'] === 'ordinal'){
        // how should someone set the ordinal list? Differet key in seriesConfig?
        return [];
      }
      var dMin = this.defaultSeriesConfig[axis+'Min'] === 'dynamic' ? Infinity: this.defaultSeriesConfig[axis+'Min'],
          dMax = this.defaultSeriesConfig[axis+'Max'] === 'dynamic' ? -Infinity: this.defaultSeriesConfig[axis+'Max'];

      mins.push(dMin);
      maxes.push(dMax);

      return [ Math.min.apply(null, mins) , Math.max.apply(null, maxes) ];
    },

    /**
    * Creates the real series confit object based on the default settings, the dev defined series config, and the includeAllSeries flag.
    *
    */
    _setCompleteSeriesConfig: function(){
      if(this._doesObjHaveValues(this.defaultSeriesConfig) && this._doesObjHaveValues(this.chartData)){
        var fullConfig = (this.seriesConfig) ? JSON.parse(JSON.stringify(this.seriesConfig)) : {},
            k = (this.includeAllSeries) ? Object.keys(this.chartData[0]) : Object.keys(fullConfig),
            xMins = [],
            xMaxes = [],
            yMins = [],
            yMaxes = [],
            chartExtents = {};

        if(k.length === 0){
          console.warn("No series were added to the chart. Either add them in the seriesConfig or turn on includeAllSeries");
          return;
        }

        // TODO is there a better way?
        if(this.includeAllSeries){
          /*
            to delete x from fullConfig, we need to know what the x key is. A seriesConfig might have it, otherwise try defaultSeriesConfig.

            First, try the first elem in the obj and hope it itself is not the x; if that doesnt work, try the last one; if that doesnt work, assume (maybe not a safe assumption) that they didnt set any x override and use default.
          */
          var x;
          if(this.seriesConfig && this.seriesConfig[k[0]]['x']){
            x = this.seriesConfig[k[0]]['x'];
          } else if(this.seriesConfig && this.seriesConfig[ k[ k.length -1 ]]['x']){
            x = this.seriesConfig[ k[ k.length -1 ]]['x'];
          } else {
            x = this.defaultSeriesConfig['x'];
          }
          delete fullConfig[x];
        }

        for(var i = 0; i < k.length; i++) {
          // check our copied seriesConfig and see what is there
          if(!fullConfig[k[i]]){
            fullConfig[k[i]] = {};
          }
          if(!fullConfig[k[i]]['type']) {
            fullConfig[k[i]]['type'] = this.defaultSeriesConfig['type'];
          }
          if(!fullConfig[k[i]]['name']) {
            fullConfig[k[i]]['name'] = k[i];
          }
          if(!fullConfig[k[i]]['x']) {
            fullConfig[k[i]]['x'] = this.defaultSeriesConfig['x'];
          }
          if(!fullConfig[k[i]]['color']) {
            fullConfig[k[i]]['color'] = this.dataVisColors[this.seriesColorOrder[i]];
          }

          if(fullConfig[k[i]]['xMin']) {
            xMins.push(fullConfig[k[i]]['xMin']);
          }
          if(fullConfig[k[i]]['xMax']) {
            xMaxes.push(fullConfig[k[i]]['xMax']);
          }
          if(fullConfig[k[i]]['yMin']) {
            yMins.push(fullConfig[k[i]]['yMin']);
          }
          if(fullConfig[k[i]]['yMax']) {
            yMaxes.push(fullConfig[k[i]]['yMax']);
          }
        }

        if(!this.chartExtents){
          chartExtents['x'] = this._calcChartExts(xMins,xMaxes,'x');
          chartExtents['y'] = this._calcChartExts(yMins,yMaxes,'y');
        } else {
          if(!this.chartExtents.x){
            chartExtents['x'] = this._calcChartExts(xMins,xMaxes,'x');
          }
          if(!this.chartExtents.y){
            chartExtents['y'] = this._calcChartExts(yMins,yMaxes,'y');
          }
        }

        this.set('chartExtents',chartExtents);
        this.fire('px-vis-chart-extents', { 'dataVar': 'chartExtents', 'data': chartExtents, 'method':'set' });

        this.set('completeSeriesConfig',fullConfig);
        this.fire('px-vis-complete-series-config', { 'dataVar': 'completeSeriesConfig', 'data': fullConfig, 'method':'set' });
      }
    },

    /**
     * Helper function that only calls _updateProperty if event originates from a child component of the chart.
     *
     * Events data packet must come in the form:
     * ```
     *  {
     *    'dataVar': variableName,  //'chartData' or 'mutedSeries.myLineSeries'
     *    'data': data,
     *    'method':'set'  //any Polymer method: 'set','push', etc
     *  }
     *```
     * @method _updateLocalProperty
     * @param {event}
     */
    _updateLocalProperty: function(evt){
      var detail = evt.detail;
      var ne = Polymer.dom(evt);
      if(ne.rootTarget.dataHost === this){
        this._updateProperty(detail);
      }
    },
    /**
     * Helper function that always calls _updateProperty regardless of origin.
     *
     * Events data packet must come in the form:
     * ```
     *  {
     *    'dataVar': variableName,  //'chartData' or 'mutedSeries.myLineSeries'
     *    'data': data,
     *    'method':'set'  //any Polymer method: 'set','push', etc
     *  }
     *```
     * @method _updateGlobalProperty
     * @param {event}
     */
    _updateGlobalProperty: function(evt){
      var detail = evt.detail;
      this._updateProperty(detail);
    },
    /**
     * Generic variable updater. Triggered by events to support precipitation pattern.
     *
     * Events data packet must come in the form:
     * ```
     *  {
     *    'dataVar': variableName,  //'chartData' or 'mutedSeries.myLineSeries'
     *    'data': data,
     *    'method':'set'  //any Polymer method: 'set','push', etc
     *  }
     *```
     * @method _updateProperty
     * @param {object}
     */
    _updateProperty: function(detail){
      this[detail.method](detail.dataVar, detail.data);
      if(detail.method !== 'set'){
        this.notifyPath(detail.dataVar,detail.data);
      }
    },
    /**
     * Helper function for the register. Returns true if the side register should exist
     *
     * @method _sideRegister
     */
    _sideRegister:function(location){
      return location === 'side' || location === 'both';
    },
    /**
     * Helper function for the register. Returns true if the top register should exist
     *
     * @method _topRegister
     */
    _topRegister:function(location){
      return location === 'top' || location === 'both';
    },
    /**
     * Helper function for the line series. Returns true if the series is a line
     *
     * @method _chartTypeLine
     */
    _chartTypeLine: function(key,obj){
        return obj[key]['type'] === 'line';
    },
    /**
     * Helper function for the line series. Returns true if the series is a line
     *
     * @method _chartTypeLine
     */
    _chartTypeScatter: function(key,obj){
      return obj[key]['type'] === 'scatter';
    },

    _returnKeys: function(obj){
      return Object.keys(obj);
    }

}, commonColors, PxVisBehavior.commonMethods];
</script>
