<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-vis-behavior-common.html" />
<link rel="import" href="px-vis-behavior-d3.html" />
<link rel="import" href="../px-colors-design/colors.html" />


<!--
Element providing user interaction on an axis.

This element draw the box over the axis signifying the active area to mute the series outside that box.


##### Usage

    <px-vis-axis-brush
        svg="[[axisGroups]]"
        axis="[[y]]"
        chart-data="[[chartData]]"
        dimensions="[[dimensions]]"
        series-key="[[seriesKey]]"
        muted-series="{{mutedSeries}}">
    </px-vis-axis-brush>

@element px-vis-axis-brush
@blurb Element providing user interaction on an axis..
@homepage index.html
@demo demo.html
-->
<dom-module id="px-vis-axis-brush">
    <link rel="import" type="css" href="css/px-vis.css"/>
    <template>

    </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-axis-brush',

    behaviors: [
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.axis,
      PxVisBehavior.commonMethods,
      PxVisBehavior.dimensions,
      PxVisBehavior.dataset,
      PxVisBehavior.mutedSeries,
      commonColors
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * Holder object for the brushes
       */
      _brushes: {
        type: Object
      },
      /**
       * holder for the original domain
       */
      _previousDomain: {
        type: Array
      }
    },

    observers: [
      'drawElement(svg)'
      // 'drawElement(svg, axis, height, margin)'
    ],

    drawElement: function() {
      this.debounce('drawBrushAxis', function(){
        var _this = this,
            domain = [
              [-10,0],
              [_this.margin.top,_this.height - _this.margin.top - _this.margin.bottom]
            ];

        if(!this._previousDomain){
          this._previousDomain = [
            [-10,0],
            [_this.margin.top,_this.height- _this.margin.top - _this.margin.bottom]
          ];
        }

        // Add and store a brush for each axis.
        this.svg.each(function(d) {
          if(Px.d3.select(this).select('g.brush').node()){
            //update the brush when resize occurs
              var brsh = Px.d3.select(this).select('g.brush'),
                  curBrush,
                  curSelection = Px.d3.brushSelection(brsh.node());

              //set appropriate domain
              brsh.call(
                curBrush = Px.d3.brushY().extent(domain)
              );

              //if currently active (=drawn) make sure we redraw the brush with appropriate
              //size and position
              if(curSelection) {
                //calculate new pos/size
                var totDomain = Math.abs(domain[1][1] - domain[1][0]),
                    totPreviousDomain = Math.abs(_this._previousDomain[1][1] - _this._previousDomain[1][0]),
                    startPercentage = curSelection[0]/totPreviousDomain,
                    stopPercentage = curSelection[1]/totPreviousDomain;

                //set it
                brsh.call(curBrush.move, [totDomain * startPercentage, totDomain * stopPercentage]);
              }
              //now restore brushing functions
              curBrush.on("start.brush", _this.brushstart.bind(_this))
                      .on("end.brush", _this.brush.bind(_this));
          } else {
            // create a new brush
            Px.d3.select(this).append("g")
            .attr("class", "brush")
            .call(
              Px.d3.brushY()
                .extent(_this._previousDomain)
                .on("start.brush", _this.brushstart.bind(_this))
                .on("end.brush", _this.brush.bind(_this))
            );
          }
        })
        .selectAll("rect")
        .attr({
          "x":-8,
          "width": 18,
          "fill": this.colors.gray5,
          "stroke": this.colors["primary-blue"]
        });

        // save these brushes for access in brush()
        this.set('_brushes',this.svg.selectAll('g.brush'));
        this.set('_previousDomain', domain);
      }.bind(this),5);
    },

    brushstart: function() {
      if(Px.d3.event.sourceEvent) {
      	Px.d3.event.sourceEvent.stopPropagation();
      }
    },

    // Handles a brush event, toggling the display of foreground lines.
    brush: function() {
      var extents = [],
        series = {},
        dim,y0,y1;
      console.log(this._brushes)
      // for each brush, figure out if it was brushed and build an array of obj with the extents and the dimension
      this._brushes.each(function(d) {
        if(Px.d3.brushSelection(this)){
          extents.push({ "extent": Px.d3.brushSelection(this), "index": d });
        }
      });

      for(var i = 0; i < this.chartData.length; i++){
        for(var j = 0; j < extents.length; j++){
          dim = extents[j]['index'];
          y0 = this.axis[dim].invert(extents[j]["extent"][1]);
          y1 = this.axis[dim].invert(extents[j]["extent"][0]);
          if(y0 > this.chartData[i][dim] || this.chartData[i][dim] > y1){
            series[this.chartData[i][this.seriesKey]] = true;
          }
        }
      }
      this.set('mutedSeries',series);
      this.fire('px-vis-muted-series-updated', { 'data': series, 'dataVar': 'mutedSeries' ,'method': 'set' });
    }
  });
</script>
