<link rel="import" href="px-vis-behavior-common.html">
<link rel="import" href="px-vis-behavior-d3.html">

<script>
var PxVisBehaviorRenderer = PxVisBehaviorRenderer || {};

/*
    Name:
    PxVisBehaviorRenderer.base

    Description:
    Polymer behavior that provides

    Dependencies:
    - none

    @polymerBehavior PxVisBehaviorRenderer.base
*/
PxVisBehaviorRenderer.base = [{
  properties: {
    /**
     * Debounce time to use for drawing
     */
    drawDebounceTime: {
      type: Number,
      value: 10
    },
    /**
    * Counter to track progressive rendering requests and only draw the latest one
    */
    _progressiveRenderingCounter: {
      type: Number,
      value: 0
    },
    /**
     * Object used to store various info about current rendering state
     */
    _renderingContext: {
      type: Object,
      value: function() {
        return {
          'lastPointRenderedIndex': null,
          'currentBatchStartIndex': 0
        };
      }
    },
    /**
     * Current registered targets to draw on canvas during rendering
     */
    _canvasTargets: {
      type: Array,
      value: function() {
        return [];
      }
    },
    /**
     * Current registered targets to draw on svg during rendering
     */
    _svgTargets: {
      type: Array,
      value: function() {
        return [];
      }
    },
    /**
     * The minimum number of points to render per frame
     * even if the chart is laggy
     */
    _minimumPointsPerFrame: {
      type: Number,
      value: 50
    },
    /**
     * Number of previous frames to average for the adaptive
     * progressive rendering
     */
    _frameCountToAverage: {
      type: Number,
      value: 15
    }
  },
  observers: ['_renderData(domainChanged, canvasContext, chartData.*, completeSeriesConfig.*, preventInitialDrawing, radial, counterClockwise, renderToCanvas)'],


  ready: function() {
    this._processCanvasRenderingBound = this._processCanvasRendering.bind(this);
  },
  attached: function() {

    this.listen(this, 'px-vis-renderer-register', '_registerDrawingElement');
    this.listen(this, 'px-vis-renderer-unregister', '_unregisterDrawingElement');

    //if we've been detached and reattached make sure we redraw (canvas clears on detached)
    if(this._isDirty) {
      this._renderData();
      this._isDirty = false;
    }
  },
  detached: function() {

    this._isDirty = true;

    //reset counter so it cancels current drawing
    this._progressiveRenderingCounter = 0;

    this.unlisten(this, 'px-vis-renderer-register', '_registerDrawingElement');
    this.unlisten(this, 'px-vis-renderer-unregister', '_unregisterDrawingElement');
  },

  _registerDrawingElement: function(e) {
    var evt = Polymer.dom(e);

    if(e.detail.renderMode === 'canvas') {
      this._canvasTargets.push({'target': evt.rootTarget, 'type': e.detail.type});
    } else {
      this._svgTargets.push({'target': evt.rootTarget, 'type': e.detail.type});
    }
  },

  _unregisterDrawingElement: function(e) {
    var evt = Polymer.dom(e),
        index = -1;

    if(e.detail.renderMode === 'canvas') {
      for(var i=0; i<this._canvasTargets.length; i++) {
        if(evt.rootTarget === this._canvasTargets[i].target) {
          index = i;
          break;
        }
      }
      if(i !== -1) {
        this._canvasTargets.splice(i,1);
      }
    } else {
      for(var i=0; i<this._svgTargets.length; i++) {
        if(evt.rootTarget === this._svgTargets[i].target) {
          index = i;
          break;
        }
      }
      if(i !== -1) {
        this._svgTargets.splice(i,1);
      }
    }
  },

  _renderData: function() {

    if(!this.preventInitialDrawing) {
      //new request
      this._progressiveRenderingCounter++;

      if(this.drawDebounceTime > 0) {
        this.debounce('drawCanvasChart',function() {
          this._renderDataDebounced(true);
        }.bind(this), this.drawDebounceTime);
      } else {
        this._renderDataDebounced(true);
      }
    } else {
      //reset counter so it cancels current drawing
      this._progressiveRenderingCounter = 0;
    }
  },

  _renderDataDebounced: function(allowCanvasClearing) {
    if(this.y &&
         typeof this.domainChanged !== 'undefined' &&
         this.domainChanged !== null &&
         this._isAttached &&
         this.chartData) {

      this._initializeCanvasRendering(allowCanvasClearing);
      this._initializeSvgRendering();
    }
  },

  _initializeCanvasRendering: function(allowCanvasClearing) {
    //clear canvas first
    if(allowCanvasClearing) {
      this.canvasContext.pxClearCanvas();
    }

    //todo: configurable initial values?
    this._renderingContext = {
      'frameIndex': 0,
      //new request
      'requestCounter': ++this._progressiveRenderingCounter,
      'size': {},
      'previousFramesTiming': [],
      'targetIndex': 0,
      'currentRenderingCounter': 0
    };

    //initialize all elements that need to draw
    if(this._canvasTargets.length) {
      for(var i=0; i<this._canvasTargets.length; i++) {
        this._canvasTargets[i].target.initializeDrawingSession();
      }

      //now start actual drawing
      this._processCanvasRendering();
    }
  },

  _processCanvasRendering: function(timing) {

    if(this._renderingContext.requestCounter !== this._progressiveRenderingCounter) {
      //new request came in, cancel this drawing. Don't reset the counter as we want
      //the new request to finish
      return;
    }

    var now = window.performance.now();
    //TODO: logic for selecting drawing order
    if(this._renderingContext.frameIndex === 0) {

      this._renderingContext.previousStartTime = window.performance.now();
      this._firstCanvasRender(this._getCurrentCanvasRenderingTarget());
      window.requestAnimationFrame(this._processCanvasRenderingBound);
    } else {

      //update how long the previous frame took
      this._renderingContext.previousFramesTiming[this._renderingContext.previousFramesTiming.length-1].duration = now - this._renderingContext.previousStartTime;

      console.log('frame ' + this._renderingContext.frameIndex + ', render: ' +JSON.stringify(this._renderingContext.previousFramesTiming[this._renderingContext.previousFramesTiming.length-1]));

      //find out how many points we can render this frame
      var toRender = this._calculatePointsAllowance(),
          target = this._getCurrentCanvasRenderingTarget();

      //store what we are going to render this frame so it's
      //available next frame
      this._renderingContext.previousFramesTiming.push({
        'points': toRender
      });

      //keep rendering while we can
      while(toRender > 1 && target) {

        toRender = this._renderTargetToCanvas(target, toRender);
        target = this._getCurrentCanvasRenderingTarget();
      }


      this._renderingContext.previousStartTime = now;

      //only average the last 10 frames
      if(this._renderingContext.previousFramesTiming.length > this._frameCountToAverage) {
        this._renderingContext.previousFramesTiming.shift();
      }
    }
    this._renderingContext.frameIndex++;

    if(this._renderingContext.targetIndex > this._canvasTargets.length-1) {

      //Everything done
      this.fire('px-vis-chart-canvas-rendering-ended');
    } else {
      //keep rendering
      window.requestAnimationFrame(this._processCanvasRenderingBound);
    }
    //event?
  },

  _getCurrentCanvasRenderingTarget: function() {

    if(this._canvasTargets.length) {
      return this._canvasTargets[this._renderingContext.targetIndex].target;
    }

    return null;
  },

  _firstCanvasRender: function(target, isScatter) {

    //try estimating how much we can render.
    var duration,
        multiplier,
        targetTiming = 8,
        pointsRendered = 0,
        toRender = Math.min(target.nodeName === 'PX-VIS-SCATTER-CANVAS' ? 200 : 1000, this.chartData.length);

    //start by rendering 50 pts
    this._renderTargetToCanvas(target, toRender)
    pointsRendered = toRender;

    duration = window.performance.now() - this._renderingContext.previousStartTime;

    //target 8ms: 16ms (60 fps) - 8ms for the browser to
    //actually draw. Crude but this is only for the first frame
    if(duration < targetTiming) {
      //find how much more we can render
      multiplier = Math.floor(targetTiming / duration);

      this._renderTargetToCanvas(target, multiplier * 10);
      pointsRendered += multiplier * 10;
    }

    this._renderingContext.previousFramesTiming.push({
      'points': pointsRendered
    });
  },

  _renderTargetToCanvas: function(target, toRender) {

    var leftInCurrentSeries = this.chartData.length - this._renderingContext.currentRenderingCounter,
        start = this._renderingContext.currentRenderingCounter,
        stop = Math.min(start + toRender, this.chartData.length);


    target.renderOneBatch(start, stop);

    if(toRender > leftInCurrentSeries) {

      //this series is done
      this._renderingContext.currentRenderingCounter = 0;
      this._renderingContext.targetIndex++;

      return toRender - leftInCurrentSeries;
    } else {
      this._renderingContext.currentRenderingCounter += toRender;
      return 0;
    }
  },

  _calculatePointsAllowance: function() {
    var totPoints = 0,
        totDuration = 0,
        avgPoints,
        avgDuration,
        pointsAddition;

      //calculate averages
      for(var i=0; i<this._renderingContext.previousFramesTiming.length; i++) {
        totPoints += this._renderingContext.previousFramesTiming[i].points;
        totDuration += this._renderingContext.previousFramesTiming[i].duration;
      }

      //adjust batch size
      avgPoints = Math.floor(totPoints/this._renderingContext.previousFramesTiming.length);
      avgDuration = totDuration/this._renderingContext.previousFramesTiming.length;
      //16ms => 60fps
      pointsAddition = Math.floor((16 - avgDuration) * (avgPoints/avgDuration));

      return Math.max(this._minimumPointsPerFrame, avgPoints + pointsAddition);
  },

  _initializeSvgRendering: function() {

    //TODO, use requestanimationframe
    if(this._svgTargets.length) {
      for(var i=0; i<this._svgTargets.length; i++) {
        this._svgTargets[i].target.initializeDrawingSession();
      }


    }

  }
}, PxVisBehaviorD3.renderToCanvas, PxVisBehavior.dataset, PxVisBehavior.polarData, PxVisBehavior.radial, PxVisBehavior.preventInitialDrawing, PxVisBehavior.isAttached];

</script>
